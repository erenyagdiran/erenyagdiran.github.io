
<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="utf-8">
      <meta name="description" content="Personal blog of Eren, about computers, math and music">
      <meta name="author" content="Eren">
      <meta name="viewport" content="width=device-width">
      <link rel="stylesheet" href="/css/syntax.css">
      <link rel="stylesheet" href="/css/main.css">
      <link rel="stylesheet" href="/css/normalize.css">
      <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
      <link rel="icon" href="/favicon.ico" type="image/x-icon">
      <link rel="alternate" type="application/atom+xml" href="/atom.xml">
      <title>An Analysis of ShellShock Malware</title>
   </head>

   <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-54909516-1', 'auto');
  ga('send', 'pageview');

</script>

   
   <body>
      <main>
         <header>
            <h1 class="title"><a href="/">m00dy's place</a></h1>
         </header>

         <article>
   <h2>An Analysis of ShellShock Malware</h2>
   <p>TL;DR
I had this malware from a gist which i dont really remember right now. I downloaded it and started to analyse what this is all about. As i analyzed so far, it&#39;s somehow broken. May be i am late ?</p>

<p>Ok lets start with file command.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">eren@lisa:~<span class="nv">$ </span>file nginx
nginx: ELF 32-bit LSB executable, Intel 80386, version <span class="m">1</span> <span class="o">(</span>SYSV<span class="o">)</span>, statically linked, <span class="k">for</span> GNU/Linux 2.6.18, stripped
eren@lisa:~<span class="err">$</span></code></pre></div>

<p>file program tells us that it&#39;s statically linked and stripped. So, Most of its dependencies are inside the code and we will have difficulties while debugging it because the debug informations have been removed.</p>

<p>We&#39;ll fire up gdb and start to debug the malware from its starting point.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">eren@lisa:~<span class="nv">$ </span>gdb nginx 
GNU gdb <span class="o">(</span>GDB<span class="o">)</span> 7.4.1-debian
Copyright <span class="o">(</span>C<span class="o">)</span> <span class="m">2012</span> Free Software Foundation, Inc.
License GPLv3+: GNU GPL version <span class="m">3</span> or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type <span class="s2">&quot;show copying&quot;</span>
and <span class="s2">&quot;show warranty&quot;</span> <span class="k">for</span> details.
This GDB was configured as <span class="s2">&quot;x86_64-linux-gnu&quot;</span>.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;...
Reading symbols from /home/eren/nginx...<span class="o">(</span>no debugging symbols found<span class="o">)</span>...done.
<span class="o">(</span>gdb<span class="o">)</span> info file
Symbols from <span class="s2">&quot;/home/eren/nginx&quot;</span>.
Local <span class="nb">exec </span>file:
    <span class="sb">`</span>/home/eren/nginx<span class="err">&#39;</span>, file <span class="nb">type </span>elf32-i386.
    Entry point: 0x8048160</code></pre></div>

<p>I&#39;ll put a breakpoint to 0x8048160</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">b * 0x8048160</code></pre></div>

<p>and then i&#39;ll run the executable and it&#39;ll will stop in its entry point.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">(</span>gdb<span class="o">)</span> b * 0x8048160
Breakpoint <span class="m">1</span> at 0x8048160
<span class="o">(</span>gdb<span class="o">)</span> r
Starting program: /home/eren/nginx 

Breakpoint 1, 0x08048160 in ?? <span class="o">()</span>
<span class="o">=</span>&gt; 0x08048160:    <span class="m">31</span> ed    xor    ebp,ebp
<span class="o">(</span>gdb<span class="o">)</span> x/20i <span class="nv">$pc</span>
<span class="o">=</span>&gt; 0x8048160: xor    ebp,ebp
   0x8048162:   pop    esi
   0x8048163:   mov    ecx,esp
   0x8048165:   and    esp,0xfffffff0
   0x8048168:   push   eax
   0x8048169:   push   esp
   0x804816a:   push   edx
   0x804816b:   push   0x804be00
   0x8048170:   push   0x804be40
   0x8048175:   push   ecx
   0x8048176:   push   esi
   0x8048177:   push   0x804b2cc
   0x804817c:   call   0x804b7c0
   0x8048181:   hlt</code></pre></div>

<p>From 0x8048160 to 0x8048181, the code blocks are standart way of glibc execution. Therefore, the malware programmer didnt modified the entry point. If you compile an empty helloworld program, you would see the same starting code like above. 
 Xoring ebp to ebp means nothing but this type of practices come from ABI (Application Binary Interface Specs). In the address of 0x804817c, the calls refers to &lt;_<em>libc</em>start_main@plt&gt; function.</p>

<p>You can look at the details <a href="http://refspecs.linuxbase.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic/baselib---libc-start-main-.html">here</a>
So, first paramether to libc<em>start</em>main function is actually the last one pushed on the stack. Therefore, 0x804b2cc is our main function. Let&#39;s put a breakpoint there and go on.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">b * 0x804b2cc</code></pre></div>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">Breakpoint 2, 0x0804b2cc in ?? <span class="o">()</span>
<span class="o">=</span>&gt; 0x0804b2cc:    8d 4c <span class="m">24</span> 04  lea    ecx,<span class="o">[</span>esp+0x4<span class="o">]</span>
<span class="o">(</span>gdb<span class="o">)</span> x/30i <span class="nv">$pc</span>
<span class="o">=</span>&gt; 0x804b2cc: lea    ecx,<span class="o">[</span>esp+0x4<span class="o">]</span>
   0x804b2d0:   and    esp,0xfffffff0
   0x804b2d3:   push   DWORD PTR <span class="o">[</span>ecx-0x4<span class="o">]</span>
   0x804b2d6:   push   ebp
   0x804b2d7:   mov    ebp,esp
   0x804b2d9:   push   edi
   0x804b2da:   push   esi
   0x804b2db:   push   ebx
   0x804b2dc:   push   ecx
   0x804b2dd:   sub    esp,0x1464
   0x804b2e3:   push   0x0
   0x804b2e5:   call   0x8056ce0
   0x804b2ea:   mov    ebx,eax
   0x804b2ec:   call   0x8057430
   0x804b2f1:   xor    eax,ebx
   0x804b2f3:   mov    DWORD PTR <span class="o">[</span>esp<span class="o">]</span>,eax
   0x804b2f6:   call   0x804cb90
   0x804b2fb:   mov    DWORD PTR <span class="o">[</span>esp<span class="o">]</span>,0x0
   0x804b302:   call   0x8056ce0
   0x804b307:   mov    ebx,eax
   0x804b309:   call   0x8057430
   0x804b30e:   xor    eax,ebx
   0x804b310:   mov    DWORD PTR <span class="o">[</span>esp<span class="o">]</span>,eax
   0x804b313:   call   0x8048240
   0x804b318:   call   0x8048fd5
   0x804b31d:   movzx  eax,BYTE PTR ds:0x80cc2b5
   0x804b324:   add    esp,0xc
   0x804b327:   push   eax
   0x804b328:   movzx  eax,BYTE PTR ds:0x80cc2b4
   0x804b32f:   push   eax
<span class="o">(</span>gdb<span class="o">)</span></code></pre></div>

<p>As you may see, the main function has a lot of calls to other functions. I&#39;ll not go into every call but cover most important aspects of its actions.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">0x8074fd0: mov    edx,ebx
   0x8074fd2:   mov    ebx,DWORD PTR <span class="o">[</span>esp+0x4<span class="o">]</span>
   0x8074fd6:   mov    eax,0x7a
   0x8074fdb:   call   DWORD PTR ds:0x80cbfd0</code></pre></div>

<p>In the forth line, i see a call to somewhere over a pointer. I need to deference it.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">(</span>gdb<span class="o">)</span> p/x *0x80cbfd0
<span class="nv">$1</span> <span class="o">=</span> 0xf7ffd420
<span class="o">(</span>gdb<span class="o">)</span> x/10i 0xf7ffd420
   0xf7ffd420 &lt;__kernel_vsyscall&gt;:    push   ecx
   0xf7ffd421 &lt;__kernel_vsyscall+1&gt;:  push   edx
   0xf7ffd422 &lt;__kernel_vsyscall+2&gt;:  push   ebp
   0xf7ffd423 &lt;__kernel_vsyscall+3&gt;:  mov    ebp,esp
   0xf7ffd425 &lt;__kernel_vsyscall+5&gt;:  sysenter</code></pre></div>

<p>After deferencing, It becomes our gate to the kernel. I wrote the address of 0x80cbfd0 somewhere to keep in my mind. We need to analyze the registers before it goes through syscall gate.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">(</span>gdb<span class="o">)</span> info reg
eax            0x7a 122
ecx            0xffffffff   -1
edx            0x0  0
ebx            0xffffd5f6   -10762
esp            0xffffd5e0   0xffffd5e0
ebp            0xffffd7c8   0xffffd7c8
esi            0x0  0
edi            0x804be00    134528512
eip            0x8074fdb    0x8074fdb
eflags         0x286    <span class="o">[</span> PF SF IF <span class="o">]</span>
cs             0x23 35
ss             0x2b 43
ds             0x2b 43
es             0x2b 43
fs             0x0  0
gs             0x0  0</code></pre></div>

<p>We need to look up syscall table for 0x7a (eax value). You can find syscall table <a href="http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html">here</a></p>

<p>122 belongs to uname syscall.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">(</span>gdb<span class="o">)</span> x/20c <span class="nv">$ebx</span>
0xffffd5f6: <span class="m">76</span> <span class="s1">&#39;L&#39;</span>   <span class="m">105</span> <span class="s1">&#39;i&#39;</span>  <span class="m">110</span> <span class="s1">&#39;n&#39;</span>  <span class="m">117</span> <span class="s1">&#39;u&#39;</span>  <span class="m">120</span> <span class="s1">&#39;x&#39;</span>  <span class="m">0</span> <span class="s1">&#39;\000&#39;</span> <span class="m">0</span> <span class="s1">&#39;\000&#39;</span> <span class="m">0</span> <span class="s1">&#39;\000&#39;</span>
0xffffd5fe: <span class="m">0</span> <span class="s1">&#39;\000&#39;</span> <span class="m">0</span> <span class="s1">&#39;\000&#39;</span> <span class="m">0</span> <span class="s1">&#39;\000&#39;</span> <span class="m">0</span> <span class="s1">&#39;\000&#39;</span> <span class="m">0</span> <span class="s1">&#39;\000&#39;</span> <span class="m">0</span> <span class="s1">&#39;\000&#39;</span> <span class="m">0</span> <span class="s1">&#39;\000&#39;</span> <span class="m">0</span> <span class="s1">&#39;\000&#39;</span>
0xffffd606: <span class="m">0</span> <span class="s1">&#39;\000&#39;</span> <span class="m">0</span> <span class="s1">&#39;\000&#39;</span> <span class="m">0</span> <span class="s1">&#39;\000&#39;</span> <span class="m">0</span> <span class="s1">&#39;\000&#39;</span></code></pre></div>

<p>So the malware got the information about my system.At least it knows which operating system im running :)</p>

<p>It uses several times of brk syscall to allocate some space from the heap.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">0x8056ce6: push   ebx
   0x8056ce7:   xor    ebx,ebx
<span class="o">=</span>&gt; 0x8056ce9: mov    eax,0xd
   0x8056cee:   call   DWORD PTR ds:0x80cbfd0</code></pre></div>

<p>Another syscall for getting time and later it will get also pid number.I&#39;ll skip these until socket things come up.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">0x805864f: nop
   0x8058650:   mov    edx,ebx
   0x8058652:   mov    eax,0x66
   0x8058657:   mov    ebx,0x1
<span class="o">=</span>&gt; 0x805865c: lea    ecx,<span class="o">[</span>esp+0x4<span class="o">]</span>
   0x8058660:   call   DWORD PTR ds:0x80cbfd0</code></pre></div>

<p>This is very important, the malware creates a socket with socket syscall.This time, eax is 102 and it is sys_socketcall in linux syscall table (i386).</p>

<p>When we look at the parameters, </p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">(</span>gdb<span class="o">)</span> info reg
eax            0x66 102
ecx            0xffffb2b0   -19792
edx            0x54302d33   1412443443
ebx            0x1  1
esp            0xffffb2ac   0xffffb2ac
ebp            0xffffc338   0xffffc338
esi            0x2e5fd200   778031616
edi            0x804be00    134528512
eip            0x8058660    0x8058660
eflags         0x282    <span class="o">[</span> SF IF <span class="o">]</span>
cs             0x23 35
ss             0x2b 43
ds             0x2b 43
es             0x2b 43
fs             0x0  0
gs             0x63 99</code></pre></div>

<p>Ebx is really important, 0x1 tells us <a href="http://lxr.free-electrons.com/source/include/uapi/linux/net.h#L26">that</a> it is a sys<em>socket and it will go down just <a href="http://lxr.free-electrons.com/source/net/socket.c#L2509">right</a> there.
Ecx is our pointer which is being passed into sys</em>socket function.</p>

<p>And then, after syscall execution, the kernel should give us a file descriptor that we can write to or read from it.</p>

<p>I go to my proc file system to see which file descriptor are mapped to my process adress space.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">eren@lisa:/proc/30480/fd<span class="nv">$ </span>ls -la
total 0
dr-x------ <span class="m">2</span> eren eren  <span class="m">0</span> Oct  <span class="m">4</span> 18:03 .
dr-xr-xr-x <span class="m">8</span> eren eren  <span class="m">0</span> Oct  <span class="m">4</span> 17:24 ..
lrwx------ <span class="m">1</span> eren eren <span class="m">64</span> Oct  <span class="m">4</span> 18:04 <span class="m">0</span> -&gt; /dev/pts/0
lrwx------ <span class="m">1</span> eren eren <span class="m">64</span> Oct  <span class="m">4</span> 18:04 <span class="m">1</span> -&gt; /dev/pts/0
lrwx------ <span class="m">1</span> eren eren <span class="m">64</span> Oct  <span class="m">4</span> 18:03 <span class="m">2</span> -&gt; /dev/pts/0
lrwx------ <span class="m">1</span> eren eren <span class="m">64</span> Oct  <span class="m">4</span> 18:04 <span class="m">3</span> -&gt; socket:<span class="o">[</span>324793<span class="o">]</span>
lrwx------ <span class="m">1</span> eren eren <span class="m">64</span> Oct  <span class="m">4</span> 18:04 <span class="m">4</span> -&gt; socket:<span class="o">[</span>324794<span class="o">]</span>
lr-x------ <span class="m">1</span> eren eren <span class="m">64</span> Oct  <span class="m">4</span> 18:04 <span class="m">5</span> -&gt; pipe:<span class="o">[</span>324795<span class="o">]</span>
l-wx------ <span class="m">1</span> eren eren <span class="m">64</span> Oct  <span class="m">4</span> 18:04 <span class="m">6</span> -&gt; pipe:<span class="o">[</span>324795<span class="o">]</span>
lrwx------ <span class="m">1</span> eren eren <span class="m">64</span> Oct  <span class="m">4</span> 18:04 <span class="m">7</span> -&gt; socket:<span class="o">[</span>327132<span class="o">]</span></code></pre></div>

<p>Yeah there it is.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">0x805844c: mov    eax,0x66
   0x8058451:   mov    ebx,0x3
   0x8058456:   lea    ecx,<span class="o">[</span>esp+0x4<span class="o">]</span>
<span class="o">=</span>&gt; 0x805845a: call   DWORD PTR ds:0x80cbfd0</code></pre></div>

<p>This time, Ebx is 0x3 that means SYS<em>CONNECT. Ecx now points to paramethers that we pushed into sys</em>connect. Let&#39;s examine the parameter.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="m">2515</span>         <span class="k">case</span> SYS_CONNECT:
<span class="m">2516</span>                 <span class="nv">err</span> <span class="o">=</span> sys_connect<span class="o">(</span>a0, <span class="o">(</span>struct sockaddr __user *<span class="o">)</span>a1, a<span class="o">[</span>2<span class="o">])</span><span class="p">;</span>
<span class="m">2517</span>                 <span class="nb">break</span><span class="p">;</span></code></pre></div>

<p>The code above is from kernel source.Paramethers are a0,a pointer and another a2. These are all 12 bytes. So ecx should point to 12 bytes.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">(</span>gdb<span class="o">)</span> x/3wx <span class="nv">$ecx</span>
0xffffb2b0: 0x00000007  0xffffc30c  0x00000010
<span class="o">(</span>gdb<span class="o">)</span></code></pre></div>

<p>Now, a0 =&gt; 0x07, sockaddr pointer is =&gt; 0xffffc30c and last paramether is 0x00000010.</p>

<p>We want to find where this malware connects. We know that sockaddr structure holds this information. Sockaddr structure is <a href="http://www.softwarerevolution.com/jeneral/ipc/include/linux/socket.h/source/SOURCE-socket.h.html">here</a></p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">typedef unsigned short sa_family_t<span class="p">;</span>
struct sockaddr <span class="o">{</span>
    sa_family_t sa_family<span class="p">;</span> /* address family, AF_xxx */
    char sa_data<span class="o">[</span>14<span class="o">]</span><span class="p">;</span> /* <span class="m">14</span> bytes of protocol address   */
<span class="o">}</span><span class="p">;</span></code></pre></div>

<p>We can do our estimation that 1 short + 14 char =&gt; 16 bytes.
So i&#39;ll skip the first 2 bytes and print the others.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">(</span>gdb<span class="o">)</span> x/14bu 0xffffc30e
0xffffc30e: 0   80  108 162 197 26  0   0
0xffffc316: 0   0   0   0   0   0</code></pre></div>

<p>So, it&#39;s clear that the malware wants to connect to 108.162.197.26 through 80 port.</p>

<p>Malware then tries to get the ip of host machine by executing getsockname.</p>

<p>It then reads &quot;/proc/net/route&quot; here to parse network interface and uses ioctl syscall to get its MAC address (SIOCGIFHWADDR).</p>

<p>Later, It forks itself and quit.</p>

<p>The forked process also tries to connect somewhere(89.238.150.154) but it cannot. I don&#39;t know why.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">root@lisa:~/blog# tcpdump -v -X dst 89.238.150.154
tcpdump: listening on eth0, link-type EN10MB <span class="o">(</span>Ethernet<span class="o">)</span>, capture size <span class="m">65535</span> bytes
18:52:50.373950 IP <span class="o">(</span>tos 0x0, ttl 64, id 46732, offset 0, flags <span class="o">[</span>DF<span class="o">]</span>, proto TCP <span class="o">(</span>6<span class="o">)</span>, length 60<span class="o">)</span>
    95.85.48.36.51746 &gt; 89.238.150.154.5: Flags <span class="o">[</span>S<span class="o">]</span>, cksum 0x8030 <span class="o">(</span>incorrect -&gt; 0x9be6<span class="o">)</span>, seq 3399773995, win 14600, options <span class="o">[</span>mss 1460,sackOK,TS val <span class="m">113698896</span> ecr 0,nop,wscale 8<span class="o">]</span>, length 0
    0x0000:  <span class="m">4500</span> 003c b68c <span class="m">4000</span> <span class="m">4006</span> 042e 5f55 <span class="m">3024</span>  E..&lt;..@.@..._U0<span class="err">$</span>
    0x0010:  59ee 969a ca22 <span class="m">0005</span> caa4 6f2b <span class="m">0000</span> <span class="m">0000</span>  Y....<span class="err">&quot;</span>....o+....
    0x0020:  a002 <span class="m">3908</span> <span class="m">8030</span> <span class="m">0000</span> <span class="m">0204</span> 05b4 <span class="m">0402</span> 080a  ..9..0..........
    0x0030:  06c6 e850 <span class="m">0000</span> <span class="m">0000</span> <span class="m">0103</span> <span class="m">0308</span>            ...P........</code></pre></div>

<p>Anyway, this malware looks harmless now :)</p>

</article>

    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'erenyagdiran'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    
<footer>
   <div id="date" class="meta">
      03 Oct 2014
   </div>
   <div id="return">
      <a href="/">&laquo; Return to the home page</a>
   </div>
</footer>

      </main>
   </body>
</html>
